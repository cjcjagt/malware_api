import tensorflow as tf
import numpy as np
path = "D:\document\\thesis\pro\malicious_dynamic_behavior_detection_by_cnn-master\malicious_dynamic_behavior_detection_by_cnn-master"
def load_model():
    # 测试数据构造：模拟2张32x32的RGB图
    X = np.array(np.arange(6144, 12288)).reshape(2, 32, 32, 3)  # 2:张，32*32：图片大小，3：RGB
    Y = [3, 1]
    Y = np.array(Y)
    X = X.astype('float32')
    X = np.multiply(X, 1.0 / 255.0)

    with tf.Session() as sess:
        # 加载元图和权重
        saver = tf.train.import_meta_graph(path + 'model\model0.5-4500.meta')
        saver.restore(sess, tf.train.latest_checkpoint(path + "model\\"))

        # 获取权重
        graph = tf.get_default_graph()  # 获取当前默认计算图
        fc2_w = graph.get_tensor_by_name("fc2/w:0")  # get_tensor_by_name后面传入的参数，如果没有重复，需要在后面加上“:0”
        fc2_b = graph.get_tensor_by_name("fc2/b:0")
        print("------------------------------------------------------")
        # print ('fc2_w:',sess.run(fc2_w))可以打印查看，这里因为数据太多了，显示太占地方了，就不打印了
        print("#######################################")
        print('fc2_b:', sess.run(fc2_b))
        print("------------------------------------------------------")

        # 预测输出
        feed_dict = {"x_input:0": X, "y_input:0": Y}
        # y = graph.get_tensor_by_name("y_input:0")
        yy = sess.run(Y, feed_dict)  # 将Y转为one-hot类型
        print('yy:', yy)
        print("the answer is: ", sess.run(tf.argmax(yy, 1)))
        print("------------------------------------------------------")

        pred_y = tf.get_collection("predict")  # 拿到原来模型中的"predict",也就是原来模型中计算得到结果y_fc2
        print('我用加载的模型来预测新输入的值了！')
        pred = sess.run(pred_y, feed_dict)[0]  # 利用原来计算y_fc2的方式计算新喂给网络的数据，即feed_dict = {"x:0":X, "y_:0":Y}
        print('pred:', pred, '\n')  # pred是新数据下得到的预测值
        pred = sess.run(tf.argmax(pred, 1))
        print("the predict is: ", pred)
        print("------------------------------------------------------")

        acc = tf.get_collection("acc")  # 同样利用原模型中的计算图acc来计算新预测的准确值
        # acc = graph.get_operation_by_name("acc")
        acc = sess.run(acc, feed_dict)  # acc是新数据下得到的准确值
        # print(acc.eval())
        print("the accuracy is: ", acc)
        print("------------------------------------------------------")


load_model()